// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_SCHEMA_BLASTER_MESSAGES_H_
#define FLATBUFFERS_GENERATED_SCHEMA_BLASTER_MESSAGES_H_

#include "flatbuffers/flatbuffers.h"

namespace Blaster {
namespace Messages {

struct Point;

struct Color;

struct BlasterMessage;
struct BlasterMessageBuilder;

struct VisualObject;
struct VisualObjectBuilder;

enum RenderMode {
    RenderMode_Polygon = 0,
    RenderMode_Line = 1,
    RenderMode_Point = 2,
    RenderMode_MIN = RenderMode_Polygon,
    RenderMode_MAX = RenderMode_Point
};

inline const RenderMode (&EnumValuesRenderMode())[3] {
    static const RenderMode values[] = {RenderMode_Polygon, RenderMode_Line,
                                        RenderMode_Point};
    return values;
}

inline const char *const *EnumNamesRenderMode() {
    static const char *const names[4] = {"Polygon", "Line", "Point", nullptr};
    return names;
}

inline const char *EnumNameRenderMode(RenderMode e) {
    if (flatbuffers::IsOutRange(e, RenderMode_Polygon, RenderMode_Point))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesRenderMode()[index];
}

enum MessageType {
    MessageType_NONE = 0,
    MessageType_VisualObject = 1,
    MessageType_MIN = MessageType_NONE,
    MessageType_MAX = MessageType_VisualObject
};

inline const MessageType (&EnumValuesMessageType())[2] {
    static const MessageType values[] = {MessageType_NONE,
                                         MessageType_VisualObject};
    return values;
}

inline const char *const *EnumNamesMessageType() {
    static const char *const names[3] = {"NONE", "VisualObject", nullptr};
    return names;
}

inline const char *EnumNameMessageType(MessageType e) {
    if (flatbuffers::IsOutRange(e, MessageType_NONE, MessageType_VisualObject))
        return "";
    const size_t index = static_cast<size_t>(e);
    return EnumNamesMessageType()[index];
}

template <typename T> struct MessageTypeTraits {
    static const MessageType enum_value = MessageType_NONE;
};

template <> struct MessageTypeTraits<Blaster::Messages::VisualObject> {
    static const MessageType enum_value = MessageType_VisualObject;
};

bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *obj,
                       MessageType type);
bool VerifyMessageTypeVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Point FLATBUFFERS_FINAL_CLASS {
  private:
    int32_t x_;
    int32_t y_;

  public:
    Point() : x_(0), y_(0) {}
    Point(int32_t _x, int32_t _y)
        : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) {
    }
    int32_t x() const { return flatbuffers::EndianScalar(x_); }
    int32_t y() const { return flatbuffers::EndianScalar(y_); }
};
FLATBUFFERS_STRUCT_END(Point, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) Color FLATBUFFERS_FINAL_CLASS {
  private:
    uint8_t r_;
    uint8_t g_;
    uint8_t b_;
    uint8_t a_;

  public:
    Color() : r_(0), g_(0), b_(0), a_(0) {}
    Color(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
        : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)),
          b_(flatbuffers::EndianScalar(_b)), a_(flatbuffers::EndianScalar(_a)) {
    }
    uint8_t r() const { return flatbuffers::EndianScalar(r_); }
    uint8_t g() const { return flatbuffers::EndianScalar(g_); }
    uint8_t b() const { return flatbuffers::EndianScalar(b_); }
    uint8_t a() const { return flatbuffers::EndianScalar(a_); }
};
FLATBUFFERS_STRUCT_END(Color, 4);

struct BlasterMessage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef BlasterMessageBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_FROM = 4,
        VT_MESSAGE_TYPE = 6,
        VT_MESSAGE = 8
    };
    int16_t from() const { return GetField<int16_t>(VT_FROM, 0); }
    Blaster::Messages::MessageType message_type() const {
        return static_cast<Blaster::Messages::MessageType>(
            GetField<uint8_t>(VT_MESSAGE_TYPE, 0));
    }
    const void *message() const { return GetPointer<const void *>(VT_MESSAGE); }
    template <typename T> const T *message_as() const;
    const Blaster::Messages::VisualObject *message_as_VisualObject() const {
        return message_type() == Blaster::Messages::MessageType_VisualObject
                   ? static_cast<const Blaster::Messages::VisualObject *>(
                         message())
                   : nullptr;
    }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) &&
               VerifyField<int16_t>(verifier, VT_FROM) &&
               VerifyField<uint8_t>(verifier, VT_MESSAGE_TYPE) &&
               VerifyOffset(verifier, VT_MESSAGE) &&
               VerifyMessageType(verifier, message(), message_type()) &&
               verifier.EndTable();
    }
};

template <>
inline const Blaster::Messages::VisualObject *
BlasterMessage::message_as<Blaster::Messages::VisualObject>() const {
    return message_as_VisualObject();
}

struct BlasterMessageBuilder {
    typedef BlasterMessage Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_from(int16_t from) {
        fbb_.AddElement<int16_t>(BlasterMessage::VT_FROM, from, 0);
    }
    void add_message_type(Blaster::Messages::MessageType message_type) {
        fbb_.AddElement<uint8_t>(BlasterMessage::VT_MESSAGE_TYPE,
                                 static_cast<uint8_t>(message_type), 0);
    }
    void add_message(flatbuffers::Offset<void> message) {
        fbb_.AddOffset(BlasterMessage::VT_MESSAGE, message);
    }
    explicit BlasterMessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    flatbuffers::Offset<BlasterMessage> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<BlasterMessage>(end);
        return o;
    }
};

inline flatbuffers::Offset<BlasterMessage>
CreateBlasterMessage(flatbuffers::FlatBufferBuilder &_fbb, int16_t from = 0,
                     Blaster::Messages::MessageType message_type =
                         Blaster::Messages::MessageType_NONE,
                     flatbuffers::Offset<void> message = 0) {
    BlasterMessageBuilder builder_(_fbb);
    builder_.add_message(message);
    builder_.add_from(from);
    builder_.add_message_type(message_type);
    return builder_.Finish();
}

struct VisualObject FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
    typedef VisualObjectBuilder Builder;
    enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
        VT_POS = 4,
        VT_OUTLINE = 6,
        VT_RENDER_MODE = 8,
        VT_COLOR = 10,
        VT_VX = 12,
        VT_VY = 14,
        VT_ROT = 16
    };
    const Blaster::Messages::Point *pos() const {
        return GetStruct<const Blaster::Messages::Point *>(VT_POS);
    }
    const flatbuffers::Vector<const Blaster::Messages::Point *> *
    outline() const {
        return GetPointer<
            const flatbuffers::Vector<const Blaster::Messages::Point *> *>(
            VT_OUTLINE);
    }
    Blaster::Messages::RenderMode render_mode() const {
        return static_cast<Blaster::Messages::RenderMode>(
            GetField<int8_t>(VT_RENDER_MODE, 1));
    }
    const Blaster::Messages::Color *color() const {
        return GetStruct<const Blaster::Messages::Color *>(VT_COLOR);
    }
    float vx() const { return GetField<float>(VT_VX, 0.0f); }
    float vy() const { return GetField<float>(VT_VY, 0.0f); }
    float rot() const { return GetField<float>(VT_ROT, 0.0f); }
    bool Verify(flatbuffers::Verifier &verifier) const {
        return VerifyTableStart(verifier) &&
               VerifyField<Blaster::Messages::Point>(verifier, VT_POS) &&
               VerifyOffset(verifier, VT_OUTLINE) &&
               verifier.VerifyVector(outline()) &&
               VerifyField<int8_t>(verifier, VT_RENDER_MODE) &&
               VerifyField<Blaster::Messages::Color>(verifier, VT_COLOR) &&
               VerifyField<float>(verifier, VT_VX) &&
               VerifyField<float>(verifier, VT_VY) &&
               VerifyField<float>(verifier, VT_ROT) && verifier.EndTable();
    }
};

struct VisualObjectBuilder {
    typedef VisualObject Table;
    flatbuffers::FlatBufferBuilder &fbb_;
    flatbuffers::uoffset_t start_;
    void add_pos(const Blaster::Messages::Point *pos) {
        fbb_.AddStruct(VisualObject::VT_POS, pos);
    }
    void add_outline(flatbuffers::Offset<
                     flatbuffers::Vector<const Blaster::Messages::Point *>>
                         outline) {
        fbb_.AddOffset(VisualObject::VT_OUTLINE, outline);
    }
    void add_render_mode(Blaster::Messages::RenderMode render_mode) {
        fbb_.AddElement<int8_t>(VisualObject::VT_RENDER_MODE,
                                static_cast<int8_t>(render_mode), 1);
    }
    void add_color(const Blaster::Messages::Color *color) {
        fbb_.AddStruct(VisualObject::VT_COLOR, color);
    }
    void add_vx(float vx) {
        fbb_.AddElement<float>(VisualObject::VT_VX, vx, 0.0f);
    }
    void add_vy(float vy) {
        fbb_.AddElement<float>(VisualObject::VT_VY, vy, 0.0f);
    }
    void add_rot(float rot) {
        fbb_.AddElement<float>(VisualObject::VT_ROT, rot, 0.0f);
    }
    explicit VisualObjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
        start_ = fbb_.StartTable();
    }
    flatbuffers::Offset<VisualObject> Finish() {
        const auto end = fbb_.EndTable(start_);
        auto o = flatbuffers::Offset<VisualObject>(end);
        return o;
    }
};

inline flatbuffers::Offset<VisualObject> CreateVisualObject(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Blaster::Messages::Point *pos = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Blaster::Messages::Point *>>
        outline = 0,
    Blaster::Messages::RenderMode render_mode =
        Blaster::Messages::RenderMode_Line,
    const Blaster::Messages::Color *color = 0, float vx = 0.0f, float vy = 0.0f,
    float rot = 0.0f) {
    VisualObjectBuilder builder_(_fbb);
    builder_.add_rot(rot);
    builder_.add_vy(vy);
    builder_.add_vx(vx);
    builder_.add_color(color);
    builder_.add_outline(outline);
    builder_.add_pos(pos);
    builder_.add_render_mode(render_mode);
    return builder_.Finish();
}

inline flatbuffers::Offset<VisualObject> CreateVisualObjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Blaster::Messages::Point *pos = 0,
    const std::vector<Blaster::Messages::Point> *outline = nullptr,
    Blaster::Messages::RenderMode render_mode =
        Blaster::Messages::RenderMode_Line,
    const Blaster::Messages::Color *color = 0, float vx = 0.0f, float vy = 0.0f,
    float rot = 0.0f) {
    auto outline__ =
        outline ? _fbb.CreateVectorOfStructs<Blaster::Messages::Point>(*outline)
                : 0;
    return Blaster::Messages::CreateVisualObject(
        _fbb, pos, outline__, render_mode, color, vx, vy, rot);
}

inline bool VerifyMessageType(flatbuffers::Verifier &verifier, const void *obj,
                              MessageType type) {
    switch (type) {
    case MessageType_NONE: {
        return true;
    }
    case MessageType_VisualObject: {
        auto ptr =
            reinterpret_cast<const Blaster::Messages::VisualObject *>(obj);
        return verifier.VerifyTable(ptr);
    }
    default:
        return true;
    }
}

inline bool VerifyMessageTypeVector(
    flatbuffers::Verifier &verifier,
    const flatbuffers::Vector<flatbuffers::Offset<void>> *values,
    const flatbuffers::Vector<uint8_t> *types) {
    if (!values || !types)
        return !values && !types;
    if (values->size() != types->size())
        return false;
    for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
        if (!VerifyMessageType(verifier, values->Get(i),
                               types->GetEnum<MessageType>(i))) {
            return false;
        }
    }
    return true;
}

inline const Blaster::Messages::BlasterMessage *
GetBlasterMessage(const void *buf) {
    return flatbuffers::GetRoot<Blaster::Messages::BlasterMessage>(buf);
}

inline const Blaster::Messages::BlasterMessage *
GetSizePrefixedBlasterMessage(const void *buf) {
    return flatbuffers::GetSizePrefixedRoot<Blaster::Messages::BlasterMessage>(
        buf);
}

inline bool VerifyBlasterMessageBuffer(flatbuffers::Verifier &verifier) {
    return verifier.VerifyBuffer<Blaster::Messages::BlasterMessage>(nullptr);
}

inline bool
VerifySizePrefixedBlasterMessageBuffer(flatbuffers::Verifier &verifier) {
    return verifier.VerifySizePrefixedBuffer<Blaster::Messages::BlasterMessage>(
        nullptr);
}

inline void FinishBlasterMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Blaster::Messages::BlasterMessage> root) {
    fbb.Finish(root);
}

inline void FinishSizePrefixedBlasterMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Blaster::Messages::BlasterMessage> root) {
    fbb.FinishSizePrefixed(root);
}

} // namespace Messages
} // namespace Blaster

#endif // FLATBUFFERS_GENERATED_SCHEMA_BLASTER_MESSAGES_H_
